flightMap :: [String]
flightMap = [
    ".........#....#.###.........##.",
    "..###.#......#......#.......##.",
    "##....#.#.......#.....#........",
    "#........#..........#.#...#...#",
    "#....###...##.....#........#...",
    "###..............##..#.....#...",
    ".................##.#..........",
    ".........##......#..###.....#.#",
    "..#..#...#.#.#...#.#.#.##...#..",
    "..............#.#.#..#..#..#...",
    ".#.#.#....#.........#.........#",
    "..#.#....##..#...#.....#..##..#",
    "............#.....#.........##.",
    "...#.#..#..........#.##.....#..",
    "#......#...##.......###........",
    ".....#....#.#..............#...",
    ".....#.......#..##.###.....#.#.",
    ".#.....#....##.#......##......#",
    "..##...##.........#..#.#..#....",
    "............#.......#.....#....",
    ".......................#...####",
]


flightPath :: [(Int,Int)] -> Int -> Int -> (Int,Int) -> [(Int,Int)]
flightPath p x y s@(sx,sy)
    | y >= length flightMap = p
    | otherwise = flightPath ((x,y):p) (x+sx) (y+sy) s

isTree :: (Int, Int) -> Bool
isTree (x, y)
    | y >= length flightMap = False
    | otherwise =  row!!(mod x $ length row) == '#'
    where row = (flightMap!!y)

treesInPath :: (Int,Int) -> [(Int,Int)]
treesInPath (sx,sy) = [p | p <- flightPath [] 0 0 (sx, sy), isTree p]

part1 :: Int
part1 = length $ treesInPath (3,1)

part2 :: Int
part2 = product $ map (length . treesInPath) [(1,1), (3,1), (5,1), (7,1), (1,2)]